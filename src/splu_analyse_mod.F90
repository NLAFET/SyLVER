!> \file
!> \copyright 2016- The Science and Technology Facilities Council (STFC)
!> \author    Florent Lopez
module splu_analyse_mod
  use, intrinsic :: iso_c_binding
  use spral_ssids_datatypes
  use spral_ssids_akeep, only: ssids_akeep 

  !
  ! Data type for information generated in analyse phase
  !
  type splu_akeep_type
     type(ssids_akeep) :: akeep ! information generated by SSIDS
     type(c_ptr) :: symbolic_tree_c ! C ptr on symbolic tree
     integer :: nsubtrees ! number of subtrees
     integer, dimension(:), allocatable :: subtree_en ! root of each subtrees
  end type splu_akeep_type

contains

  !****************************************************************************
  !
  ! Build a map from A to nodes
  ! lcol( nlist(2,i) ) = val( nlist(1,i) )
  ! followed by
  ! ucol( nlist(2,i) ) = val( nlist(1,i) )
  ! nptr defines start of each node in nlist
  
  subroutine build_map(n, ptr, row, perm, invp, nnodes, sptr, rptr, rlist, &
       nptr, nlist, st)
    implicit none
    
    ! Matrix A
    integer, intent(in) :: n
    integer(long), dimension(n+1), intent(in) :: ptr ! Column pointer (whole matrix)
    integer, dimension(ptr(n+1)-1), intent(in) :: row ! Row indices (whole matrix)
    ! Permutation and its inverse (some entries of perm may be negative to
    ! act as flags for 2x2 pivots, so need to use abs(perm))
    integer, dimension(n), intent(in) :: perm
    integer, dimension(n), intent(in) :: invp
    ! Supernode partition of L
    integer, intent(in) :: nnodes
    integer, dimension(nnodes+1), intent(in) :: sptr
    ! Row indices of L
    integer(long), dimension(nnodes+1), intent(in) :: rptr
    integer, dimension(rptr(nnodes+1)-1), intent(in) :: rlist
    ! Output mapping
    integer(long), dimension(nnodes+1), intent(out) :: nptr
    ! integer(long), dimension(2, ptr(n+1)-1), intent(out) :: nlist
    integer(long), dimension(2, 2*(ptr(n+1)-1)), intent(out) :: nlist
    ! Error check paramter
    integer, intent(out) :: st

    integer, dimension(:), allocatable :: ptr2, row2 ! Hold the transpose of A
    integer(long), dimension(:), allocatable :: origin
    integer, dimension(:), allocatable :: map
    integer :: blkm ! Number of rows in the supernode 
    integer :: blkn ! Number of columns in the fully-summed 
    integer :: i, j, k
    integer(long) :: ii, jj, pp
    integer :: col
    integer :: node

    ! Build A transpose in ptr2, row2 and store original position for
    ! matrix entries.
    allocate(ptr2(n+3), row2(ptr(n+1)-1), origin(ptr(n+1)-1), stat=st)
    if (st .ne. 0) return

    ! Count number of entries in row i in ptr2(i+2).
    ptr2(:) = 0
    do i = 1, n
       do jj = ptr(i), ptr(i+1)-1
          k = row(jj)
          ptr2(k+2) = ptr2(k+2) + 1
       end do
    end do
    ! Work out row starts such that row i starts in posn ptr2(i+1)
    ptr2(1:2) = 1
    do i = 1, n
       ptr2(i+2) = ptr2(i+2) + ptr2(i+1)
    end do
    ! Drop entries into place
    do i = 1, n
       do jj = ptr(i), ptr(i+1)-1
          k = row(jj)
          row2(ptr2(k+1)) = i
          origin(ptr2(k+1)) = jj
          ptr2(k+1) = ptr2(k+1) + 1
       end do
    end do    
    
    allocate(map(n), stat=st)
    if (st .ne. 0) return
    
    !
    ! Build nptr and nlist
    !
    pp = 1
    do node = 1, nnodes
       blkm = int(rptr(node+1) - rptr(node)) ! Front dimensions
       nptr(node) = pp
       blkn = int(sptr(node+1) - sptr(node)) ! Number of fully-summed rows/columns
       
       ! Build map for node indices
       do jj = rptr(node), rptr(node+1)-1
          map(rlist(jj)) = int(jj-rptr(node)+1)
       end do

       ! Build nlist from A

       ! lcol
       do j = sptr(node), sptr(node+1)-1
          col = invp(j) ! Col of L
          do ii = ptr(col), ptr(col+1)-1
             k = abs(perm(row(ii))) ! row of L
             nlist(2,pp) = (j-sptr(node))*blkm + map(k)
             nlist(1,pp) = ii
             pp = pp + 1
          end do
       end do

       ! print *, 'lcol = ', nlist(2,nptr(node):pp-1) / blkm 
       ! print *, 'val = ', nlist(2,nptr(node):pp-1) 
       ! ii = pp
       
       ! ucol
       do i = sptr(node), sptr(node+1)-1
          k = abs(perm(i)) ! row of U
          do j = ptr2(k), ptr2(k+1)-1
             col = invp(row2(j)) ! Col of U
             nlist(2,pp) = blkm*blkn + map(col)*blkn + i
             nlist(1,pp) = origin(j)
             pp = pp + 1
          end do
       end do

       ! print *, 'ucol = ', nlist(2,ii:pp-1)
       
    end do
    nptr(nnodes+1) = pp
    
  end subroutine build_map
  
  subroutine analyse_core(splu_akeep, n, ptr, row, order, invp, options, inform)
    use spral_ssids_akeep, only: ssids_akeep
    use spral_core_analyse, only : basic_analyse
    use spldlt_datatypes_mod
    use sylver_inform_mod
    use spldlt_analyse_mod, only: spldlt_create_symbolic_tree_c, prune_tree, spldlt_print_atree
    implicit none

    type(splu_akeep_type), target, intent(inout) :: splu_akeep ! spldlt akeep structure 
    integer, intent(in) :: n ! order of system
    integer(long), intent(in) :: ptr(n+1) ! col pointers (whole matrix)
    integer, intent(in) :: row(ptr(n+1)-1) ! row indices (whole matrix)
    integer, dimension(n), intent(inout) :: order
      !  On exit, holds the pivot order to be used by factorization.
    integer, dimension(n), intent(out) :: invp 
      ! Work array. Used to hold inverse of order but
      ! is NOT set to inverse for the final order that is returned.
    type(sylver_options), target, intent(in) :: options ! SyLVER options
    type(sylver_inform), intent(inout) :: inform

    type(ssids_akeep), pointer :: akeep ! SSIDS akeep structure
    type(c_ptr) :: cakeep
    integer :: nemin ! Amalgamation parameter
    integer :: flag
    integer :: i, j ! Indexes
    integer(long) :: nz ! ptr(n+1)-1
    integer :: st ! Stat

    ! Tree prunnig
    integer, dimension(:), allocatable :: small
    integer, dimension(:), allocatable :: subtree_sa 
    integer :: nth ! Number of regions on CPU
    integer, dimension(:), allocatable :: contrib_dest, exec_loc
    
    akeep => splu_akeep%akeep ! Point to SSIDS analyse data

    ! Check nemin and set to default if out of range.
    nemin = options%nemin
    if (nemin .lt. 1) nemin = sylver_nemin_default

    ! Perform basic analysis so we can figure out subtrees we want to construct
    call basic_analyse(n, ptr, row, order, akeep%nnodes, akeep%sptr, &
         akeep%sparent, akeep%rptr, akeep%rlist,                     &
         nemin, flag, inform%stat, inform%num_factor, inform%num_flops)
    select case(flag)
    case(0)
       ! Do nothing
    case(-1)
       ! Allocation error
       inform%flag = SYLVER_ERROR_ALLOCATION
       return
    case(1)
       ! Zero row/column.
       inform%flag = SYLVER_WARNING_ANAL_SINGULAR
    case default
       ! Should never reach here
       inform%flag = SYLVER_ERROR_UNKNOWN
    end select

    ! set invp to hold inverse of order
    do i = 1,n
       invp(order(i)) = i
    end do
    ! any unused variables are at the end and so can set order for them
    do j = akeep%sptr(akeep%nnodes+1), n
       i = invp(j)
       order(i) = 0
    end do

    ! Build map from A to L in nptr, nlist
    nz = ptr(n+1) - 1
    ! allocate(akeep%nptr(n+1), akeep%nlist(2,nz), stat=st)
    allocate(akeep%nptr(n+1), akeep%nlist(2,2*nz), stat=st) ! FIXME nlist does not need to be 2*nz large
    if (st .ne. 0) go to 100
    call build_map(n, ptr, row, order, invp, akeep%nnodes, akeep%sptr, &
         akeep%rptr, akeep%rlist, akeep%nptr, akeep%nlist, st)
    if (st .ne. 0) go to 100

    nth = size(akeep%topology) ! FIXME Use (total) number of procs?

    ! Allocate structures and init for tree prunning
    allocate(small(akeep%nnodes+1), contrib_dest(akeep%nnodes+1), &
         subtree_sa(akeep%nnodes+1), stat=st)
    if (st .ne. 0) go to 100
    ! TODO Use temp array and copy result into subtree_en to save
    ! memory
    allocate(splu_akeep%subtree_en(akeep%nnodes+1))
    allocate(exec_loc(akeep%nnodes+1))
    
    splu_akeep%nsubtrees = 0
    small = 0
    contrib_dest = 0
    subtree_sa = 0
    splu_akeep%subtree_en = 0

    ! Find out sequential subtrees
    if (options%prune_tree) then
       call prune_tree(akeep%nnodes, akeep%sptr, akeep%sparent, akeep%rptr, nth, &
            splu_akeep%nsubtrees, small, contrib_dest, subtree_sa, &
            splu_akeep%subtree_en, exec_loc)
    end if

    print *, "[analyse_core] nsubtrees = ", splu_akeep%nsubtrees
    ! print *, "[analyse_core] contrib_dest = ", contrib_dest(1:splu_akeep%nsubtrees)
    ! print *, "[analyse_core] subtrees = ", splu_akeep%subtree_en(1:splu_akeep%nsubtrees)
#if defined(SYLVER_USE_STARPU) && defined(SYLVER_USE_OMP)
    print *, "[analyse_core] exec_loc = ", exec_loc(1:splu_akeep%nsubtrees)
#endif    
    ! dump atree in a dot file
    call spldlt_print_atree(akeep%nnodes, akeep%sptr, akeep%sparent, akeep%rptr, small)

    ! Construct symbolic subtrees
    ! allocate(akeep%subtree(akeep%nparts))
    allocate(akeep%subtree(splu_akeep%nsubtrees))

    ! do i = 1, splu_akeep%nsubtrees

    !    ! akeep%subtree(i)%exec_loc = exec_loc(i)
    !    akeep%subtree(i)%exec_loc = 1
    !    ! if (akeep%subtree(i)%exec_loc .eq. -1) cycle
    !    ! CPU
    !    akeep%subtree(i)%ptr => construct_cpu_symbolic_subtree(akeep%n,   &
    !         subtree_sa(i), splu_akeep%subtree_en(i)+1,                              &
    !                             !akeep%part(i), akeep%part(i+1),                              &
    !         akeep%sptr, akeep%sparent,                                   &
    !         akeep%rptr, akeep%rlist, akeep%nptr, akeep%nlist,            &
    !                             ! contrib_dest(akeep%contrib_ptr(i):akeep%contrib_ptr(i+1)-1), &
    !         contrib_dest(1:0), &
    !         ssids_opts)
    ! end do

    
    ! call C++ analyse routine
    ! cakeep = c_loc(akeep)
    cakeep = c_null_ptr

    splu_akeep%symbolic_tree_c = &
         spldlt_create_symbolic_tree_c(cakeep, akeep%n, akeep%nnodes, & 
         akeep%sptr, akeep%sparent, akeep%rptr, akeep%rlist, akeep%nptr, &
         akeep%nlist, splu_akeep%nsubtrees, splu_akeep%subtree_en, small, &
         contrib_dest, exec_loc)

    ! Clean memory
    deallocate(small)
    deallocate(contrib_dest)
    deallocate(subtree_sa)
    deallocate(exec_loc)

100 continue

    inform%stat = st
    if (inform%stat .ne. 0) then
       inform%flag = SSIDS_ERROR_ALLOCATION
    end if
    
  end subroutine analyse_core
  
  !****************************************************************************
  
  !> @brief Analyse phase for symmetrically-structured, non symmetric matrix.
  !>
  ! TODO 32-bits wrapper
  subroutine splu_analyse(splu_akeep, n, ptr, row, options, inform, ncpu, val)
    use spral_ssids, only: ssids_free
    use spral_metis_wrapper, only : metis_order
    use spral_ssids_akeep, only: ssids_akeep
    use spldlt_datatypes_mod
    use sylver_inform_mod
    implicit none

    type(splu_akeep_type), target, intent(inout) :: splu_akeep ! SpLU akeep structure 
    integer, intent(in) :: n ! Matrix order
    integer(long), intent(in) :: ptr(:) ! col pointers (whole triangle)
    integer, intent(in) :: row(:) ! row indices (whole triangle)
    type(sylver_options), target, intent(in) :: options ! SyLVER options
    type(sylver_inform), intent(inout) :: inform
    integer, intent(inout) :: ncpu ! number of CPU workers
    real(wp), optional, intent(in) :: val(:) ! Used when computing the scaling 

    logical :: check = .false. ! TODO input parameter
    type(ssids_akeep), pointer :: akeep ! SSIDS akeep structure
    integer(long) :: nz     ! entries in expanded matrix

    ! Error flags
    character(50)  :: context      ! Procedure name (used when printing).
    integer :: st
    integer :: free_flag
    integer :: flag         ! error flag for metis

    integer, dimension(:), allocatable :: order2 ! Computed order
    integer(long), dimension(:), allocatable :: lwr_ptr ! col ptrs for lower triangular matrix
    integer, dimension(:), allocatable :: lwr_row ! row indices for lower triangular matrix

    integer :: i
    integer ncpu_topo

    context = 'splu_analyse'

    ! Prepare analysis phase
    akeep => splu_akeep%akeep ! Analyse data in SSIDS 

    ! Initialize
    call ssids_free(akeep, free_flag)
    ! TODO Check error flags for ssids_free
    ! if (free_flag .ne. 0) then
    !    return
    ! end if

    akeep%check = check
    akeep%n = n

    ! TODO As in SSIDS analyse_double routine
    ! Checking of matrix data
    ! Check options%ordering has a valid value
    ! check val present when expected

    st = 0
    ! if (check) then
    ! TODO
    ! else
    nz = ptr(n+1)-1
    ! end if

    ! FIXME lwr_row does not need to be that large
    allocate(akeep%invp(n),order2(n),lwr_ptr(n+1),lwr_row(nz),stat=st)

    ! Extract lower triangular part of matrix
    call get_l_pattern(n, nz, ptr, row, lwr_ptr, lwr_row)

    select case(options%ordering)
    case(0)
       print *, "Not implemented"
       ! TODO
    case(1)
       ! METIS ordering
       call metis_order(n, lwr_ptr, lwr_row, order2, akeep%invp, &
            flag, inform%stat)
       ! call expand_pattern(n, nz, ptr, row, ptr2, row2)
    case(2)
       ! matching-based ordering required
       ! Expand the matrix as more efficient to do it and then
       ! call match_order_metis() with full matrix supplied
       print *, "Not implemented"
       ! TODO
    end select

    ncpu_topo = ncpu
    ! ncpu = 2
    ! ncpu_topo = 2*ncpu

    ! Figure out topology
    ! Create simple topology with ncpu regions, one for each CPU
    ! worker
    if (allocated(akeep%topology)) deallocate(akeep%topology, stat=st)
    allocate(akeep%topology(ncpu_topo), stat=st)
    do i = 1, ncpu_topo
       akeep%topology(i)%nproc = 1
       allocate(akeep%topology(i)%gpus(0), stat=st)
    end do
    ! print *, "Input topology"
    ! do i = 1, size(akeep%topology)
    !    print *, "Region ", i, " with ", akeep%topology(i)%nproc, " cores"
    !    if(size(akeep%topology(i)%gpus).gt.0) &
    !         print *, "---> gpus ", akeep%topology(i)%gpus
    ! end do

    ! perform rest of analyse
    ! if (check) then
    ! else
    call analyse_core(splu_akeep, n, ptr, row, order2, akeep%invp, options, inform)
    ! call analyse_core(spldlt_akeep, n, lwr_ptr, lwr_row, ptr, row, order2, akeep%invp, &
    !      options, inform)
    ! end if

100 continue

    inform%stat = st
    if (inform%stat .ne. 0) then
       inform%flag = SYLVER_ERROR_ALLOCATION
    end if
    call inform%print_flag(options, context)

  end subroutine splu_analyse

  !> @brief Extract lower triangular part of an imput matrix stored in
  !> a CSC (Compressed Sparse Column) format.
  !>
  subroutine get_l_pattern(n, nz, ptr, row, aptr, arow)
    implicit none

    integer, intent(in) :: n ! order of system
    integer(long), intent(in) :: nz ! Number of non zero entries
    integer(long), intent(in) :: ptr(n+1)
    integer, intent(in) :: row(nz)
    integer(long), intent(out) :: aptr(n+1) ! Row indices (whole matrix)
    integer, intent(out) :: arow(nz)

    integer :: i,j
    integer(long) :: kk
    integer(long) :: cnz ! Number of nnz in current column
    integer(long) :: sa ! Start index

    sa = 1
    aptr = 0
    ! Set aptr(j) to hold no. nonzeros in column j
    do j = 1, n
       aptr(j) = sa
       cnz = 0
       do kk = ptr(j), ptr(j+1) - 1
          i = row(kk)
          if (i .ge. j) then
             arow(sa+cnz) = i
             cnz = cnz + 1
          end if
       end do
       sa = sa + cnz
    end do
    aptr(n+1) = sa

    ! print *, "nnz = ", aptr(n+1)-1
    ! print *, "aptr = ", aptr
    ! print *, "arow = ", arow(1:aptr(n+1)-1)

  end subroutine get_l_pattern
  
end module splu_analyse_mod
