!> \file
!> \copyright 2016- The Science and Technology Facilities Council (STFC)
!> \author    Florent Lopez
module splu_analyse_mod
  use, intrinsic :: iso_c_binding
  use spral_ssids_datatypes
  use spral_ssids_akeep, only: ssids_akeep 

  !
  ! Data type for information generated in analyse phase
  !
  type splu_akeep_type
     type(ssids_akeep) :: akeep ! information generated by SSIDS
     type(c_ptr) :: symbolic_tree_c ! C ptr on symbolic tree
     integer :: nsubtrees ! number of subtrees
     integer, dimension(:), allocatable :: subtree_en ! root of each subtrees
  end type splu_akeep_type

contains

  subroutine analyse_core(splu_akeep, n, ptr, row, order, invp, options)
    use spral_ssids_akeep, only: ssids_akeep
    use spral_core_analyse, only : basic_analyse
    use spldlt_datatypes_mod
    implicit none

    type(splu_akeep_type), target, intent(inout) :: splu_akeep ! spldlt akeep structure 
    integer, intent(in) :: n ! order of system
    integer(long), intent(in) :: ptr(n+1) ! col pointers (whole matrix)
    integer, intent(in) :: row(ptr(n+1)-1) ! row indices (whole matrix)
    integer, dimension(n), intent(inout) :: order
      !  On exit, holds the pivot order to be used by factorization.
    integer, dimension(n), intent(out) :: invp 
      ! Work array. Used to hold inverse of order but
      ! is NOT set to inverse for the final order that is returned.
    type(sylver_options), target, intent(in) :: options ! SyLVER options

    type(ssids_akeep), pointer :: akeep ! SSIDS akeep structure
    integer :: nemin ! Amalgamation parameter
    
    akeep => splu_akeep%akeep ! Point to SSIDS analyse data

    ! Check nemin and set to default if out of range.
    nemin = options%nemin
    if (nemin .lt. 1) nemin = sylver_nemin_default

    
  end subroutine analyse_core
  
  !****************************************************************************
  
  !> @brief Analyse phase for symmetrically-structured, non symmetric matrix.
  !>
  ! TODO 32-bits wrapper
  subroutine splu_analyse(splu_akeep, n, ptr, row, options, inform, ncpu, val)
    use spral_ssids, only: ssids_free
    use spral_metis_wrapper, only : metis_order
    use spral_ssids_akeep, only: ssids_akeep
    use spldlt_datatypes_mod
    use sylver_inform_mod
    implicit none

    type(splu_akeep_type), target, intent(inout) :: splu_akeep ! SpLU akeep structure 
    integer, intent(in) :: n ! Matrix order
    integer(long), intent(in) :: ptr(:) ! col pointers (whole triangle)
    integer, intent(in) :: row(:) ! row indices (whole triangle)
    type(sylver_options), target, intent(in) :: options ! SyLVER options
    type(sylver_inform), intent(inout) :: inform
    integer, intent(inout) :: ncpu ! number of CPU workers
    real(wp), optional, intent(in) :: val(:) ! Used when computing the scaling 

    character(50)  :: context      ! Procedure name (used when printing).
    logical :: check = .false. ! TODO input parameter
    type(ssids_akeep), pointer :: akeep ! SSIDS akeep structure
    integer(long) :: nz     ! entries in expanded matrix

    ! Error flags
    integer :: st
    integer :: free_flag
    integer :: flag         ! error flag for metis

    integer, dimension(:), allocatable :: order2 ! Computed order
    integer(long), dimension(:), allocatable :: lwr_ptr ! col ptrs for lower triangular matrix
    integer, dimension(:), allocatable :: lwr_row ! row indices for lower triangular matrix

    integer :: i
    integer ncpu_topo

    context = 'splu_analyse'

    ! Prepare analysis phase
    akeep => splu_akeep%akeep ! Analyse data in SSIDS 

    ! Initialize
    call ssids_free(akeep, free_flag)
    ! TODO Check error flags for ssids_free
    ! if (free_flag .ne. 0) then
    !    return
    ! end if

    akeep%check = check
    akeep%n = n

    ! TODO As in SSIDS analyse_double routine
    ! Checking of matrix data
    ! Check options%ordering has a valid value
    ! check val present when expected

    st = 0
    ! if (check) then
    ! TODO
    ! else
    nz = ptr(n+1)-1
    ! end if

    ! FIXME lwr_row does not need to be that large
    allocate(akeep%invp(n),order2(n),lwr_ptr(n+1),lwr_row(nz),stat=st)

    ! Extract lower triangular part of matrix
    call get_l_pattern(n, nz, ptr, row, lwr_ptr, lwr_row)

    select case(options%ordering)
    case(0)
       print *, "Not implemented"
       ! TODO
    case(1)
       ! METIS ordering
       call metis_order(n, lwr_ptr, lwr_row, order2, akeep%invp, &
            flag, inform%stat)
       ! call expand_pattern(n, nz, ptr, row, ptr2, row2)
    case(2)
       ! matching-based ordering required
       ! Expand the matrix as more efficient to do it and then
       ! call match_order_metis() with full matrix supplied
       print *, "Not implemented"
       ! TODO
    end select

    ncpu_topo = ncpu
    ! ncpu = 2
    ! ncpu_topo = 2*ncpu

    ! Figure out topology
    ! Create simple topology with ncpu regions, one for each CPU
    ! worker
    if (allocated(akeep%topology)) deallocate(akeep%topology, stat=st)
    allocate(akeep%topology(ncpu_topo), stat=st)
    do i = 1, ncpu_topo
       akeep%topology(i)%nproc = 1
       allocate(akeep%topology(i)%gpus(0), stat=st)
    end do
    ! print *, "Input topology"
    ! do i = 1, size(akeep%topology)
    !    print *, "Region ", i, " with ", akeep%topology(i)%nproc, " cores"
    !    if(size(akeep%topology(i)%gpus).gt.0) &
    !         print *, "---> gpus ", akeep%topology(i)%gpus
    ! end do

    ! perform rest of analyse
    ! if (check) then
    ! else
    call analyse_core(splu_akeep, n, ptr, row, order2, akeep%invp, options)
    ! call analyse_core(spldlt_akeep, n, lwr_ptr, lwr_row, ptr, row, order2, akeep%invp, &
    !      options, inform)
    ! end if

    return
100 continue

    print *, "[Error][splu_analyse] st: ", st

    return

  end subroutine splu_analyse

  !> @brief Extract lower triangular part of an imput matrix stored in
  !> a CSC (Compressed Sparse Column) format.
  !>
  subroutine get_l_pattern(n, nz, ptr, row, aptr, arow)
    implicit none

    integer, intent(in) :: n ! order of system
    integer(long), intent(in) :: nz ! Number of non zero entries
    integer(long), intent(in) :: ptr(n+1)
    integer, intent(in) :: row(nz)
    integer(long), intent(out) :: aptr(n+1) ! Row indices (whole matrix)
    integer, intent(out) :: arow(nz)

    integer :: i,j
    integer(long) :: kk
    integer(long) :: cnz ! Number of nnz in current column
    integer(long) :: sa ! Start index

    sa = 1
    aptr = 0
    ! Set aptr(j) to hold no. nonzeros in column j
    do j = 1, n
       aptr(j) = sa
       cnz = 0
       do kk = ptr(j), ptr(j+1) - 1
          i = row(kk)
          if (i .ge. j) then
             arow(sa+cnz) = i
             cnz = cnz + 1
          end if
       end do
       sa = sa + cnz
    end do
    aptr(n+1) = sa

    ! print *, "nnz = ", aptr(n+1)-1
    ! print *, "aptr = ", aptr
    ! print *, "arow = ", arow(1:aptr(n+1)-1)

  end subroutine get_l_pattern
  
end module splu_analyse_mod
